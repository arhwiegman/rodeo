
```{r, cache=FALSE, echo=FALSE}
# Set work folder
knitr::opts_knit$set(root.dir="examples/linked/waterSediment")
```

#### Problem description

The model considers interaction between water column and the underlying bottom sediments (figure below). Both, water column and sediment are treated as being perfectly mixed. A particulate component `x` is transfered from water to sediment via settling and it undergoes degradation in both water and sediment. Degradation releases a dissolved component `s` being subject to diffusive transport across the sediment-water interface. The water column concentrations are also affected by external in-/outflow of `x` and `s`. For the sake of simplicity, the model has no spatial resolution.

![](examples/linked/waterSediment/fig/system.png)

The model is implemented in two versions.

In the **single-object version**, water and sediment compartment are treated together as a single object, resulting in an ordinary, 0-dimensional ODE model. This is the reference implementation producing the 'exact' numerical solution. Integration is performed with the default method of [`deSolve`](http://cran.r-project.org/package=deSolve).

In the **multi-object version**, water and sediment are treated as two separate, 0-dimensional objects. Data are exchanged between the two sub-models after predefined time steps. At present, the coupling time step is identical to the output time step (but automatic adjustment would be possible). The dynamic simulation can be performed either with [`deSolve`](http://cran.r-project.org/package=deSolve) or with the `rodeo`-internal ODE solver (see class method `step`).

In general, objects are either linked via state variables or flux rates. In the latter case, a 'work-share convention' is required that specifies which object (of the two linked objects) actually computes the flux. In the considered case, it seems reasonable to let the water column object compute the settling flux of `x` and make the sediment object responsible for the diffusive flux of `s`. The linkage between the two objects is fully described by the table below. It specifies which output (source item/type) of which object (source object) supplies the value for a particular parameter in a different object (target).

```{r echo=FALSE}
x <- rbind(
 c("sett", "sed", "flux_x", "wat", "sett", "process rate"),
 c("diff", "sed", "xWat", "wat", "xWat", "state variable"),
 c("diff", "wat", "flux_s", "sed", "diff", "process rate")
)
colnames(x) <- c("Link process", "Target obj.", "Target param.", "Source obj.", "Source item", "Source type")
knitr::kable(as.data.frame(x))
```

#### Single-object version

The tabular model definition, function implementation, R source code, and output of the single-object version follows below.

<div class='htmlTableBackground'>
```{r, echo=FALSE, results='asis', comment=''}
rd <- function(f) {read.table(paste0("singleObject/",f) ,sep="\t", header=TRUE)}
knitr::kable(rd("vars.txt"), caption="Declaration of state variables (file 'vars.txt').")
knitr::kable(rd("pars.txt"), caption="Declaration of parameters (file 'pars.txt').")
knitr::kable(rd("funs.txt"), caption="Declaration of functions (file 'funs.txt').")
knitr::kable(rd("pros.txt"), caption="Definition of process rates (file 'pros.txt').")
knitr::kable(rd("stoi.txt"), caption="Definition of stoichiometric factors (file 'stoi.txt').")
```
</div>

```{r echo=FALSE, eval=TRUE, comment=''}
f <- "functions.f95"
text <- readLines(f, n=-1L, ok=TRUE, warn=TRUE, encoding="unknown", skipNul=FALSE)
cat(paste(text,"\n"))
```

```{r cache=FALSE, echo=FALSE}
knitr::read_chunk("xecute_singleObject.r")
```

```{r ref.label='singleObjectVersion', echo=TRUE, eval=TRUE, fig.height=6}
```

#### Multi-object version

In the multi-object version, the objects need to be instantiated from a separate set of tables (shown below). The function implementation does not differ from the above single-object case.

<div class='htmlTableBackground'>
```{r, echo=FALSE, results='asis', comment=''}
rd <- function(f) {read.table(paste0("multiObject/",f) ,sep="\t", header=TRUE)}
obj <- c(wat="water column", sed="sediment")

for (i in 1:length(obj))
  print(knitr::kable(rd(paste0(names(obj[i]),"_vars.txt")),
    caption=paste0("State variables of the ",obj[i]," object (file '",names(obj)[i],"_vars.txt').")))
for (i in 1:length(obj))
  print(knitr::kable(rd(paste0(names(obj[i]),"_pars.txt")),
    caption=paste0("Parameters of the ",obj[i]," object (file '",names(obj)[i],"_pars.txt').")))
for (i in 1:length(obj))
  print(knitr::kable(rd(paste0(names(obj[i]),"_funs.txt")),
    caption=paste0("Functions of the ",obj[i]," object (file '",names(obj)[i],"_funs.txt').")))
for (i in 1:length(obj))
  print(knitr::kable(rd(paste0(names(obj[i]),"_pros.txt")),
    caption=paste0("Processes of the ",obj[i]," object (file '",names(obj)[i],"_pros.txt').")))
for (i in 1:length(obj))
  print(knitr::kable(rd(paste0(names(obj[i]),"_stoi.txt")),
    caption=paste0("Stoichiometry of the ",obj[i]," object (file '",names(obj)[i],"stoi.txt').")))
```
</div>

In the R source code (see below), the two objects are stored in a list to allow for convenient iteration using methods like `lapply`. The code section performing the actual simulation is wrapped into a `system.time()` construct. This can be used to compare the performance of the `deSolve`-based solution with the one based on `rodeo`'s internal ODE solver.

```{r cache=FALSE, echo=FALSE}
knitr::read_chunk("xecute_multiObject.r")
```

```{r ref.label='multiObjectVersion', echo=TRUE, eval=TRUE, results='hold', fig.height=8}
```

The above graphical output from the multi-object version shows good agreement with the reference (i. e. the output of the single-object version). This finding, however, is not universal and the mismatch can be large for other models depending on the frequency of inter-model communication.

```{r, cache=FALSE, echo=FALSE}
# Reset work folder
knitr::opts_knit$set(root.dir=NULL)
```
